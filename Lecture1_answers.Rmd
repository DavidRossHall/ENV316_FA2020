---
title: "Example Markdown for Njal's Questions"
author: "David Hall"
date: "11/09/2020"
output: pdf_document
---

## Notes on reading this document

This document is writting in R markdown (more on that later). For now, there's three things to note. First text like this is to be treated like any other text you read, say from a course handout. Text in the grey box (see below) is the code you would write in R as code. You can literally copy, paste it into R, and run it as is and you should get the same outputs. Lastly, the outputs you'd observe in R are printed after the two hastags (##), see below. 

```{r}
# This is a comment, anythign after the '#' won't be interpreted by R. 
# Use comments to comunicate ideas and concepts to make your code legibly

# This is the input box, i.e. the R code we ran
paste("This is the ouput box")
```

# Part 1: R basics

## Task 1: Subtract 3 from 5
```{r}
3 - 5
```

R has numerous mathematical operators. These work the same as they would on your calculator. Table 1 below shows example of the other mathemical operators in R.  

```{r table-simple, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
require(pander)
panderOptions('table.split.table', Inf)
set.caption("Arithmetic Operators in R")
my.data <- "
  Operator        | Description           | Example | ... evaluates to
  +               | addition              | 1 + 2   | 3 
  -               | subtraction           | 1 - 2   | -1 
  *               | multiplication        | 3 * 2   | 6 
  ^               | exponent              | 3 ^ 3   | 27 
  /               | division              | 7 / 3   | 2.333333   
  %%              | modulus (remainder from division) | 7 %% 2   | 1 
  %/%             | integer division      |   7 %/% 3       | 2
  "
df <- read.delim(textConnection(my.data),header=FALSE,sep="|",strip.white=TRUE,stringsAsFactors=FALSE)
names(df) <- unname(as.list(df[1,])) # put headers on
df <- df[-1,] # remove first row
row.names(df)<-NULL
pander(df, style = 'rmarkdown')
```

## Task 2:  Make an object called "a" and assign this object a value of 5
```{r}
a <- 5
a = 5  
5 -> a 

# All of the above work, but the '<-' notation is prefered due to legibility.

a # simply calling a variable will return it's value

```

There's an historic reason behing the `<-` notation, but in the current version of R, `=` and `->` work the same. **That being said, the preferred notation in R is** `<-` for legibility reasons. When you see something like `a <- 5` you read it as "I'm putting the value of 5 into the variable a". `<-` allows you to explicitly express to readers of your code which value goes where, wheras something like `a = b` is ambiguous to the unfamiliar reader. It could mean "a has the value of b" or "a is equal to b" (leading to confusion with `=` and `==`, which have very different meanings in R). *Even though you can don't use the `5 -> a`*. 

##Task 3: Make an object called "b" and assign it a value of 3

```{r}
# Using the prefered '<-' notation

b <- 3
```

In R studio take a look at the "Environment" window on the upper right panel. Here you'll see a list of all variables and functions in your current R session. You should see that "a" has a value of "5" and that "b" has a value of "3". You can now reference these values using using the variable names (see next task). 

## Task 4:  Subtract "a" from "b"

```{r}
b - a
```

Because both variables "a" and "b" are numeric, we can manipulate them using mathematical operators. `b

## Task 5: Overwrite "a" into a value of your choosing 

```{r}
a <- 10
a
```

The way to think of 'overwritting' is that a variable is a box. Only one type of thing can be in it (a number, a data.frame, etc.). When you use the `<-` notation you're "putting a value into the box". When you 'overwrite' a variable like we did above with `a <- 10` you're "kicking out the previously value from the box and placing the new value into it". This type of stuff is really useful later on when you're making functions and loops, but we'll cross that bridge later on. 

## Task 7: Overwrite "a" into a name of your choosing
a <- "test"
```{r}
a <- "test" # Note the quotation marks
a

```

R can work with text, but it's called "strings". When you code in R, anything between quotation marks (i.e. "some text " or 'some other text') is interpreted as a string. In the above, we kicked out the value of 10 from "a" and inserted the value of "test". Now when you call "a" it'll return "test". Working with strings is important for a lot of data analysis later on, and there's plenty of strange tricks to it, but for now, remember that anything between quotation marks is a string, even if it has number. 

```{r, echo = TRUE}
a <- 10
is.numeric(a)

a <- "10"
is.numeric(a)
```

## Task 8: Subtract b from a

```{r, error=TRUE}
a <- "test"
b <- 3

a - b
```

Note that it doesn't work. The mathematical oeprators only work on numeric values (i.e. numbers like 1 or 3.14159...). You can't substract the value of "2" from the word "test". 

# Part 2: Functions & plotting 

R can be used to manipulate numbers, but it's much more powerful than that. R comes pre-programmed with many functions that allow you do virtually anything with numbers and data. Functions are always defined as a description with no spaces, e.g., "examplefunction", followed by a set of parentheses. e.g., "examplefunction()". Within the parentheses the user specifies how the function is applied, based on the rules of that function.

```{r, echo = TRUE}
# R can be used to manipulate numbers, but it's much more powerful than that. R comes pre-programmed with many functions that allow you do virtually anything with numbers and data. Functions are always defined as a description with no spaces, e.g., "examplefunction", followed by a set of parentheses. e.g., "examplefunction()". Within the parentheses the user specifices how the function is applied, based on the rules of that function.

#Task 10: Let’s find the mean of my.data. Try googling it.

#Task 11: Let’s find the variance of my.data … again, try googling it to find out how

# Task 12: Lets get R to randomly generate set of 50 values from a normal distribution with a mean of 30 and an SD of 25. Try googling how to do this, e.g., google "generate 50 values from a normal distribution in R". Click on any website that seems like it might tell you how … Now that we've identified the function using google, let's ask R for specific instructions on how to use this function

#Now use that function to generate the dataset


# Task 13: Note that R has produced the dataset for you, but R has not saved it for you. This is why objects are great, because you can save or “assign” this dataset as an object. Let’s call the object Normal.Dist

# Task 14: Let's use a histogram to plot it. Not sure how to make a histogram in R? Try googling it in the form of a question.

# Task 15: Lets get R to randomly generate set of 500 values from a normal distribution with a mean of 0.5 and an SD of 0.1, save these data as an object called "Normal.Dist.2"


#Part 3: installing and using packages
# So far we have been using functions that are part of the R "base package", i.e., these functions like rnorm() and hist() are pre-loaded whenever you start R. To get the most out of R, you will have to install "packages", which you download into your R library then load into R whenever you need functions in a particular package. You have two options to download a library. The first is to point your clicker to the "Tools" icon at the top of your screen and go to "Install Packages". Then type the name of the package you need into the box. Your second option to install a package is to use the function "install.packages()". So for example if we wanted to install a called "ggplot2", we would type, install.packages("ggplot2")

#Let's use a package to do a data transformation on our Normal.Dist.2 data. Recall that our Normal.Dist.2 data has a mean of 0.5 and an SD of 0.1, meaning that all values in your Normal.Dist.2 dataset are between 0 and 1. A popular transformation of data that is between 0 and 1 is called a logit transformation; the logit used prior to running transformation is used prior to running statistical analyses on this type of data (especially proportions) so that model predictions cannot exceed 0 or 1.

# Task 16: Your goal is to find out what R package will allow you to do a logit transformation on your data (using google), to install this package, and to load the package into R using the library() function.

# Task 17: Now perform a logit transformation on your Normal.Dist.2 data object.

#Now save the transformed data as a new object, called "logit.Normal.Dist.2"

#Task 18: Make a histogram of these data 

#Part 3: Introduction to Data Analysis
# Lastly, let’s use R to analyze a hypothetical dataset. Let’s say want to collect trout data from a contaminated and uncontaminated lake. Let’s pretend we performed random sampling, so that we know the data were collected without bias. For the purposes of illustration, we can generate some fake data and analyze it.
#Use rnorm to make up some fake fish weights. 
FishWeight.Cont.data<-rnorm(20,mean=11,sd=1)
FishWeight.Clean.data<-rnorm(20,mean=11,sd=1)

####Now we’ll use R to make a dataframe, so that we can analyze the data

#tell R to create a vector where the word “Cont” is ‘repeated’ (rep) the same number of times (length) as the vector  FishWeight.Cont.data
Lake.Cont<-rep("Cont", times=length(FishWeight.Cont.data))

#tell R to create a vector where the word “Clean” is ‘repeated’ (rep) the same number of times (length) as the vector  FishWeight.Clean.data
Lake.Clean<-rep("Clean", times=length(FishWeight.Clean.data))
#cbind is “column bind” so now we’re telling R to created an object where FishWeight and LakeCont are side-by-side
dat.Cont<-cbind(FishWeight.Cont.data, Lake.Cont)

#have a look at what you did
dat.Cont

#now do the same for the data for the clean lake
dat.Clean<-cbind(FishWeight.Clean.data, Lake.Clean)


#now use the function rbind (row bind) to place dat.Cont and dat.Clean in the same rows, one atop the other
dat<-rbind(dat.Cont,dat.Clean)

#To make sure R analyzes it properly, tell R that what you created is a dataframe
dat<-as.data.frame(dat)

#Tell R that the fist column [1] in the data frame is called “FishWeight”, and the second column [2] is “Lake”
colnames(dat)[1] <- "FishWeight"
colnames(dat)[2] <- "Lake" 

#Tell R that “lake” is a factor (i.e., a grouping variable, not a continuous variable).
dat$Lake<-as.factor(dat$Lake)

# Tell R that “FishWeight” is a continuous variable (i.e., not a grouping variable). To do this, you must first convert “FishWeight” to a character, then to a number. If you are curious why go to https://stackoverflow.com/questions/6328771/changing-values-when-converting-column-type-to-numeric . It’s not important to the class though.
dat$FishWeight<-as.character(dat$FishWeight)
dat$FishWeight<-as.numeric(dat$FishWeight)


#now voila, have a look at your dataframe!
dat

#Now lets run the anova
my.anova<-aov(FishWeight~Lake, data=dat)
summary(my.anova)

#Let’s look at the data means for each type of lake

data.Cont<-(dat[which(dat$Lake=="Cont"), ])
mean(data.Cont$FishWeight)

data.Clean<-(dat[ which(dat$Lake=="Clean"), ])
mean(data.Clean$FishWeight)

#We can even make a quick boxplot it if we like
plot(dat$FishWeight~dat$Lake, xlab="Lake", ylab="Fish Weight")



#Let’s back up a minute, and see how we can do things more efficiently by using a function

FishWeights<-c(FishWeight.Cont.data, FishWeight.Clean.data)
LakeID<-c(Lake.Cont, Lake.Clean)

#Let’s use the dataframe function, allowing us to skip a few steps
fish.data <- data.frame(FishWeights, LakeID, stringsAsFactors=FALSE)

#now we can run the anova again, with the same result.
my.anova<-aov(FishWeights~LakeID, data=fish.data)
summary(my.anova)

#Let’s look at the data means for each type of lake

data.Cont<-(fish.data [which(fish.data $LakeID=="Cont"), ])
mean(data.Cont$FishWeights)

data.Clean<-(fish.data [ which(fish.data $LakeID=="Clean"), ])
mean(data.Clean$FishWeights)

#We can even make a quick boxplot it if we like
boxplot(FishWeights~LakeID, xlab="Lake", ylab="Fish Weight", data=fish.data)

```

